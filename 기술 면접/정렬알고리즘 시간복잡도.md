# 정렬 알고리즘 시간 복잡도



## Bubble Sort 시간복잡도

버블 정렬의 시간 복잡도를 계산하면 best, worst, average case 모두 **O(n^2)**의 시간복잡도를 갖는다.

(처음 n, 그 다음 n-1, 그 다음 n-2 ...... 2, 1 = n+(n-1)+(n-2) .... 2+1 = n(n-1)/2 = O(n^2))

왜냐하면 이미 정렬이 되어 있든 안되어 있든 n개의 input이 있을 때 n개의 대해서 각각 n번, 즉 for문을 2번 돌기 때문에 (교환이 일어나지 않더라도 비교는 계속 진행하기 때문에) 최상, 최악, 평균의 경우 모두 O(n^2)의 시간복잡도를 갖게 된다.

## 퀵 정렬 시간복잡도

![img](정렬알고리즘 시간복잡도.assets/2751A039575C21332A)

![img](정렬알고리즘 시간복잡도.assets/2546B63F575C22F130)

따라서 시간 복잡도는 다음과 같다.

![img](정렬알고리즘 시간복잡도.assets/213D8746575C23C61D)

이제 2)의 경우를 살펴보자

![img](정렬알고리즘 시간복잡도.assets/2160B03A575C24D530)

따라서 시간 복잡도는 다음과 같다.

![img](정렬알고리즘 시간복잡도.assets/250BCA3A575C251214)

대개 2)의 경우는 다소 극단적인 상황이고, 통계적으로 1)의 경우를 선호한다. ( **∵** 주어진 모집단에서 임의의 변량 하나를 뽑는 경우, 그 확률분포는 정규분포로 근사할 수 있으며(이산 확률의 정규 근사), 따라서 이 진술은 타당하다.) 따라서 시간 복잡도는 1)의 경우로 사용하는 것이 합리적이다. 더 엄밀한 증명을 위해선 확률통계론을 사용해야 한다.



출처: https://nate9389.tistory.com/130 [정빈이의 공부방]

## 병합 정렬 시간복잡도

합병정렬의 Divide 단계에서 분할되는 깊이가 logN에 비례합니다.

각 깊이별로 Divide가 수행되어 합병해야되는 배열의 수는 많아지지만, 총 원소의 수는 똑같습니다. (N개)

따라서 각 깊이별로 수행되는 merge의 시간복잡도는 O(N)이 됩니다.

이것을 모든 깊이에 대해(logN개만큼) 수행하기 때문에 시간복잡도는 O(N * logN)이 됩니다.